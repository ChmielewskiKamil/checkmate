package db

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
)

// MutationAnalysis is the root structure for storing the complete state and results
// of the mutation analysis process, including overall statistics, per-file analysis,
// and progress tracking for mutant slaying and language model review.
type MutationAnalysis struct {
	// OverallStats summarizes the mutation testing results across the entire codebase.
	OverallStats OverallStats `json:"overallStats"`

	// AnalyzedFiles contains detailed statistics and LLM-generated recommendations
	// for each source file processed. The map key is the path to original file (e.g., "src/Vault.sol").
	AnalyzedFiles map[string]AnalyzedFile `json:"analyzedFiles"`

	// SlayingProgress tracks which mutants have been tested by the slaying tool (checkmate).
	SlayingProgress SlayingProgress `json:"slayingProgress"`

	// LanguageModelProgress tracks which surviving mutants have been reviewed by an LLM.
	LanguageModelProgress LanguageModelProgress `json:"languageModelProgress"`
}

// OverallStats includes information that should be presented for the whole
// codebase at the end of the Mutant Slaying phase such as total generated,
// slain, unslain and the overall mutation score.
type OverallStats struct {
	// MutantsTotalGenerated is the total number of mutants initially generated by the mutation tool (Gambit).
	MutantsTotalGenerated int32 `json:"mutantsTotalGenerated"`

	// MutantsTotalSlain is the total number of mutants killed by tests so far.
	MutantsTotalSlain int32 `json:"mutantsTotalSlain"`

	// MutantsTotalUnslain is the total number of mutants that survived test execution so far.
	MutantsTotalUnslain int32 `json:"mutantsTotalUnslain"`

	// MutationScore represents the effectiveness of the test suite in killing mutants,
	// calculated as (MutantsTotalSlain / MutantsTotalGenerated).
	MutationScore float32 `json:"mutationScore"`
}

// AnalyzedFile holds the statistics and LLM-generated recommendations specific to a single source file.
type AnalyzedFile struct {
	// FileSpecificStats provides a summary of mutation testing results for this file.
	FileSpecificStats FileSpecificStats `json:"fileSpecificStats"`

	// FileSpecificRecommendations is a list of aggregated suggestions or test cases
	// generated by the LLM for the unslain mutants (survivors) within this file.
	FileSpecificRecommendations []string `json:"fileSpecificRecommendations"`
}

// FileSpecificStats contains mutation testing metrics for an individual source file.
type FileSpecificStats struct {
	// MutantsTotalGenerated is the number of mutants generated for this specific file.
	MutantsTotalGenerated int32 `json:"mutantsTotalGenerated"`

	// MutantsTotalSlain is the number of mutants slain by tests within this specific file.
	MutantsTotalSlain int32 `json:"mutantsTotalSlain"`

	// MutantsTotalUnslain is the number of mutants that survived tests within this specific file.
	MutantsTotalUnslain int32 `json:"mutantsTotalUnslain"`

	// MutationScore is the mutation score for this specific file.
	MutationScore float32 `json:"mutationScore"`
}

// SlayingProgress indicates which mutants have been processed by the automated test execution phase.
type SlayingProgress struct {
	// MutantsProcessed is a map where the key is the mutant ID and the value is 'true'
	// if the mutant has been tested. This helps in resuming the slaying process
	// in a situation when the program is stopped.
	MutantsProcessed map[string]bool `json:"mutantsProcessed"`
}

// LanguageModelProgress indicates which surviving mutants have been reviewed by the LLM.
type LanguageModelProgress struct {
	// MutantsProcessed is a map where the key is the ID of a surviving mutant and the value is 'true'
	// if this survivor has been sent to an LLM for analysis and recommendations.
	// This helps in resuming the LLM review process.
	MutantsProcessed map[string]bool `json:"mutantsProcessed"`
}

// --- Persistence Functions ---

// SaveStateToFile atomically saves the MutationAnalysis data to a JSON file.
// It first writes to a temporary file and then renames it to the target filename.
// It uses a named return 'err' to reliably manage cleanup operations in defers.
func SaveStateToFile(filename string, data *MutationAnalysis) (err error) {
	if data == nil {
		// Assign to named return 'err' and return.
		// The 'return' statement by itself will return the current value of 'err'.
		err = fmt.Errorf("cannot save nil MutationAnalysis data")
		return
	}

	var jsonData []byte
	jsonData, err = json.MarshalIndent(data, "", "  ") // Using indent for readability
	if err != nil {
		err = fmt.Errorf("failed to marshal MutationAnalysis data to JSON: %w", err)
		return
	}

	// Create a temporary file in the same directory as the target file.
	// This is important for os.Rename to be atomic on most systems.
	dir := filepath.Dir(filename)
	var tempFile *os.File // Declare tempFile here to ensure it's in scope for defers if CreateTemp fails

	// Assign CreateTemp's error directly to the named return 'err'.
	tempFile, err = os.CreateTemp(dir, filepath.Base(filename)+".*.tmp")
	if err != nil {
		err = fmt.Errorf("failed to create temporary file: %w", err)
		// tempFile is nil here, so defers that use tempFile.Name() or tempFile.Close()
		// would panic if not careful. However, we return immediately.
		// The defer below will still run, but its 'err != nil' condition will be true.
		// We need to ensure os.Remove isn't called on a nil tempFile.Name().
		// So, the defer needs to be conditional on tempFile being non-nil or declared after tempFile creation.
		return
	}

	// Defer cleanup actions. This defer will run after the function's operations complete
	// or if a 'return' statement is encountered.
	var closedExplicitly bool
	defer func() {
		// This func captures the final value of 'err' (the named return)
		// and 'closedExplicitly'.
		if !closedExplicitly {
			// If the file wasn't closed explicitly, try to close it.
			// This is a best-effort close; its error is typically not handled here
			// as the function might already be returning a more primary error.
			tempFile.Close()
		}

		// If the SaveStateToFile function is returning an error (err != nil),
		// attempt to remove the temporary file.
		if err != nil {
			// No need to check if tempFile is nil here because if CreateTemp failed,
			// we would have returned before this defer's os.Remove could be problematic.
			// os.Remove will fail gracefully if the file doesn't exist (e.g., if rename succeeded).
			os.Remove(tempFile.Name())
		}
	}()

	// Write data to the temporary file.
	// Use a new variable for the Write error to avoid prematurely setting the named 'err',
	// which would trigger the cleanup defer's os.Remove path if Write succeeds but a later step fails.
	var writeErr error
	_, writeErr = tempFile.Write(jsonData)
	if writeErr != nil {
		err = fmt.Errorf("failed to write data to temporary file %s: %w", tempFile.Name(), writeErr)
		return // Named 'err' is set, defer will run and clean up.
	}

	// Close the file explicitly before renaming, especially important on Windows.
	var closeErr error
	closeErr = tempFile.Close()
	if closeErr != nil {
		err = fmt.Errorf("failed to close temporary file %s: %w", tempFile.Name(), closeErr)
		return // Named 'err' is set, defer will run and clean up.
	}
	closedExplicitly = true // Mark that we've closed it.

	// Rename the temporary file to the actual target file. This is the atomic part.
	var renameErr error
	renameErr = os.Rename(tempFile.Name(), filename)
	if renameErr != nil {
		err = fmt.Errorf("failed to rename temporary file %s to %s: %w", tempFile.Name(), filename, renameErr)
		// If rename fails, the temp file still exists. The defer will see 'err != nil'
		// and attempt to remove tempFile.Name().
		return
	}

	// If we reach here, all operations were successful. 'err' is nil.
	return nil
}

// LoadStateFromFile loads the MutationAnalysis data from a JSON file.
// If the file does not exist, it returns a zero-valued MutationAnalysis struct and no error,
// allowing the caller to initialize a new state.
// If the file exists but an error occurs during reading or unmarshalling, an error is returned.
func LoadStateFromFile(filename string) (MutationAnalysis, error) {
	var data MutationAnalysis

	fileData, err := os.ReadFile(filename)
	if err != nil {
		if os.IsNotExist(err) {
			// File doesn't exist, return a new, empty (zero-value) struct.
			// The caller can then initialize it as needed.
			// Ensure all maps are initialized to be usable.
			return initializeMutationAnalysis(), nil
		}
		// Another error occurred (e.g., permission issue)
		return data, fmt.Errorf("failed to read state file %s: %w", filename, err)
	}

	// If file is empty, json.Unmarshal might not error but data would be zero-value.
	// This is usually fine and handled like a new state.
	if len(fileData) == 0 {
		return initializeMutationAnalysis(), nil
	}

	err = json.Unmarshal(fileData, &data)
	if err != nil {
		return data, fmt.Errorf("failed to unmarshal JSON data from %s: %w", filename, err)
	}

	// Ensure maps are not nil after unmarshalling, even if they were empty in JSON.
	// json.Unmarshal will create empty maps if the JSON has `{}`, but if a field
	// was entirely absent from the JSON for a map type, the map in the struct might be nil.
	// For robustness, explicitly initialize if nil.
	if data.AnalyzedFiles == nil {
		data.AnalyzedFiles = make(map[string]AnalyzedFile)
	}
	if data.SlayingProgress.MutantsProcessed == nil {
		data.SlayingProgress.MutantsProcessed = make(map[string]bool)
	}
	if data.LanguageModelProgress.MutantsProcessed == nil {
		data.LanguageModelProgress.MutantsProcessed = make(map[string]bool)
	}

	return data, nil
}

// initializeMutationAnalysis creates a new MutationAnalysis struct with its maps initialized.
func initializeMutationAnalysis() MutationAnalysis {
	return MutationAnalysis{
		AnalyzedFiles: make(map[string]AnalyzedFile),
		// Initialize boolans to false
		SlayingProgress: SlayingProgress{
			MutantsProcessed: make(map[string]bool),
		},
		// Initialize boolans to false
		LanguageModelProgress: LanguageModelProgress{
			MutantsProcessed: make(map[string]bool),
		},
		// OverallStats will be zero-valued, which is fine for a new analysis.
	}
}
